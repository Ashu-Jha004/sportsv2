generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// EXISTING ATHLETE MODEL (ENHANCED)
// ============================================
enum AdminRole {
  FOUNDER
  CO_FOUNDER
  ADMIN
  MODERATOR_ADMIN
}

model Athlete {
  id                      String           @id @default(cuid())
  clerkUserId             String           @unique
  username                String?          @unique
  email                   String           @unique
  firstName               String?
  lastName                String?
  profileImage            String?
  dateOfBirth             DateTime?
  gender                  Gender?
  bio                     String?
  primarySport            Sport?
  secondarySport          Sport?
  rank                    Rank             @default(PAWN)
  class                   Class            @default(E)
  roles                   Role[]           @default([ATHLETE])
  isAdmin                 Boolean          @default(false)
  adminRole               AdminRole?
  adminGrantedBy          String? // ID of admin who granted this role
  adminGrantedAt          DateTime?
  country                 String?
  state                   String?
  city                    String?
  latitude                Float?
  longitude               Float?
  onboardingComplete      Boolean          @default(false)
  teamsOwned              Team[]           @relation("TeamsOwned")
  teamMembership          TeamMembership?
  // Team invitations (two separate relations)
  teamInvitationsReceived TeamInvitation[] @relation("Invitation_InvitedAthlete")
  teamInvitationsSent     TeamInvitation[] @relation("Invitation_InvitedBy")

  // Team join requests (applicant vs reviewer)
  teamJoinRequests         TeamJoinRequest[] @relation("JoinRequest_Applicant")
  teamJoinRequestsReviewed TeamJoinRequest[] @relation("JoinRequest_Reviewer")

  // Team chat and posts
  teamMessagesSent TeamMessage[] @relation("TeamMessageSender")
  teamPosts        TeamPost[]    @relation("TeamPostAuthor")

  // Team applications (as applicant)
  teamApplications TeamApplication[] @relation("TeamApplicationApplicant")

  // Team matches
  teamMatchesCreated    TeamMatch[]            @relation("TeamMatchCreator")
  teamMatchParticipants TeamMatchParticipant[] @relation("MatchParticipantAthlete")

  counters  AthleteCounters?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  // Relations
  // Evaluation requests sent by this athlete
  evaluationRequests PhysicalEvaluationRequest[]

  Guide              Guide?
  stats              Stats?
  notifications      Notification[] @relation("AthleteNotifications")
  actorNotifications Notification[] @relation("NotificationActor")

  // Follower/Following
  followers Follow[] @relation("AthleteFollowing")
  following Follow[] @relation("AthleteFollowers")

  // Messaging
  conversations Conversation[] @relation("ConversationParticipants")
  messagesSent  Message[]      @relation("MessagesSent")

  @@index([clerkUserId])
  @@index([country, state, city])
  @@index([username, firstName, email])
  @@index([latitude, longitude, primarySport])
  @@index([roles])
}

model Guide {
  id            String   @id @default(uuid())
  user          Athlete  @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String   @unique
  guideEmail    String?  @unique
  documents     String[]
  PrimarySports String?
  Sports        String[]
  Experience    Int?
  state         String?
  lat           Float?
  lon           Float?
  city          String?
  country       String?

  status     String    @default("pending_review") // "pending_review", "approved", "rejected"
  reviewNote String? // Admin notes when approving/rejecting
  reviewedBy String? // Admin user ID who reviewed
  reviewedAt DateTime? // When the review was completed

  // Evaluation requests received by this guide
  evaluationRequests       PhysicalEvaluationRequest[]
  // NEW back-relations
  overseenTeams            Team[]                      @relation("GuideOverseerTeam")
  teamApplicationsReviewed TeamApplication[]           @relation("GuideTeamApplication")
  overseenMatches          TeamMatch[]                 @relation("GuideMatchOverseer")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([id, PrimarySports, Sports, lat, lon, city, country, status])
  @@map("Guide")
}

model AdminAction {
  id               String   @id @default(cuid())
  adminUserId      String // Admin who performed the action
  action           String // "APPROVE_MODERATOR", "GRANT_ADMIN", etc.
  targetUserId     String? // User affected by the action
  targetResource   String? // "MODERATOR_APPLICATION", "USER", etc.
  targetResourceId String? // ID of the affected resource
  details          Json? // Additional action details
  ipAddress        String?
  userAgent        String?
  createdAt        DateTime @default(now())

  @@index([adminUserId, createdAt])
  @@index([action, createdAt])
  @@map("admin_actions")
}

//user Stats
model Stats {
  id        String  @id @default(uuid())
  athlete   Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  athleteId String  @unique

  height              Float?
  weight              Float?
  age                 Int?
  bodyFat             Float?
  waistCircumference  Float?
  neckCircumference   Float?
  calfCircumference   Float?
  bicepsCircumference Float?
  thighCircumference  Float?
  armSpan             Float?
  legLength           Float?
  bodyMassIndex       Float?

  injuries          InjuryStat[]         @relation("InjuryStats")
  strength          StrengthAndPower[]   @relation("StrengthAndPowerRelation")
  speed             SpeedAndAgility[]    @relation("SpeedAndAgilityRelation")
  stamina           StaminaAndRecovery[] @relation("StaminaAndRecoveryRelation")
  createdAt         DateTime             @default(now())
  updatedAt         DateTime             @updatedAt
  // Metadata for tracking updates
  lastUpdatedBy     String? // guide ID who last updated
  lastUpdatedAt     DateTime?
  lastUpdatedByName String? // For display purposes
  history           StatsHistory[]

  @@index([athleteId, createdAt, updatedAt])
  @@map("user_stats")
}

// Individual injury tracking records
model InjuryStat {
  id                   String    @id @default(uuid())
  statId               String
  stats                Stats     @relation("InjuryStats", fields: [statId], references: [id], onDelete: Cascade)
  type                 String
  bodyPart             String
  severity             String
  occurredAt           DateTime
  recoveryTime         Int?
  expectedRecoveryDate DateTime?
  recoveredAt          DateTime?
  treatmentPlan        String?
  status               String    @default("active")
  notes                String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  @@index([statId, createdAt, updatedAt])
}

// Cardiovascular and recovery metrics
model StaminaAndRecovery {
  id     String @id @default(uuid())
  statId String
  stats  Stats  @relation("StaminaAndRecoveryRelation", fields: [statId], references: [id], onDelete: Cascade)

  //updated field names to be more descriptive
  Beep_Test   Json?
  Yo_Yo_Test  Json?
  Cooper_Test Json?

  Sit_and_Reach_Test Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([statId, createdAt, updatedAt])
}

// Speed and agility performance metrics
model SpeedAndAgility {
  id                      String @id @default(uuid())
  statId                  String
  stats                   Stats  @relation("SpeedAndAgilityRelation", fields: [statId], references: [id], onDelete: Cascade)
  //updated field names to be more descriptive
  Ten_Meter_Sprint        Json?
  Fourty_Meter_Dash       Json?
  Repeated_Sprint_Ability Json?

  Illinois_Agility_Test       Json?
  Visual_Reaction_Speed_Drill Json?

  Reactive_Agility_T_Test Json?
  Standing_Long_Jump      Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([statId, createdAt, updatedAt])
}

// Strength and power performance metrics
model StrengthAndPower {
  id     String @id @default(uuid())
  statId String
  stats  Stats  @relation("StrengthAndPowerRelation", fields: [statId], references: [id], onDelete: Cascade)

  // Test metadata
  testDate DateTime? @default(now())

  // ============================================
  // JUMP TESTS (JSON - stores full test data with attempts)
  // ============================================
  Countermovement_Jump Json? // CountermovementJumpTest
  Loaded_Squat_Jump    Json? // LoadedSquatJumpTest
  Depth_Jump           Json? // DepthJumpTest

  // ============================================
  // UPPER BODY POWER TESTS (JSON)
  // ============================================
  Ballistic_Bench_Press Json? // BallisticBenchPressTest
  Push_Up               Json? // PushUpTest
  Ballistic_Push_Up     Json? // BallisticPushUpTest

  // ============================================
  // LOWER BODY STRENGTH TESTS (JSON)
  // ============================================
  Deadlift_Velocity  Json? // DeadliftVelocityTest
  Barbell_Hip_Thrust Json? // BarbellHipThrustTest

  // ============================================
  // UPPER BODY STRENGTH TESTS (JSON)
  // ============================================
  Weighted_Pull_up Json? // WeightedPullUpTest
  Barbell_Row      Json? // BarbellRowTest

  // ============================================
  // ENDURANCE/STABILITY TESTS (JSON)
  // ============================================
  Plank_Hold Json? // PlankHoldTest

  // ============================================
  // CALCULATED SCORES (0-100 scale)
  // ============================================
  muscleMass        Float? @default(0)
  enduranceStrength Float? @default(0)
  explosivePower    Float? @default(0)

  // ============================================
  // METADATA
  // ============================================
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([statId, createdAt, updatedAt])
  @@index([testDate])
  @@map("strength_and_power")
}

// Complete audit trail of statistics changes
model StatsHistory {
  id      String @id @default(cuid())
  StatsId String

  stats Stats @relation(fields: [StatsId], references: [id], onDelete: Cascade)

  // What was changed
  oldValues Json[]
  newValues Json[]

  // Who made the change
  updatedBy     String // guide ID
  updatedByName String // guide name for display

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([StatsId, createdAt, updatedAt])
  @@map("stats_history")
}

// Initial evaluation request from athlete to guide
model PhysicalEvaluationRequest {
  id               String        @id @default(cuid())
  athleteId        String
  guideId          String
  status           RequestStatus @default(PENDING)
  message          String? // Optional message from athlete
  MessageFromguide String?
  OTP              Int?          @unique
  location         String?
  athlete          Athlete       @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  guide            Guide         @relation(fields: [guideId], references: [id], onDelete: Cascade)
  scheduledDate    DateTime?
  scheduledTime    String?
  equipment        String[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([OTP, guideId, athleteId])
  @@map("physical_evaluation_requests")
}

// ============================================
// NOTIFICATION SYSTEM (POLYMORPHIC DESIGN)
// ============================================
// System-wide notification management
model Notification {
  id        String           @id @default(uuid())
  athleteId String // Changed from Int to String to match User.id
  athlete   Athlete          @relation("AthleteNotifications", fields: [athleteId], references: [id])
  actorId   String? // Changed from Int to String to match User.id
  actor     Athlete?         @relation("NotificationActor", fields: [actorId], references: [id])
  type      NotificationType
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false) // Removed duplicate 'read' field
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  @@index([athleteId, isRead])
}

// Notification categories
enum NotificationType {
  STAT_UPDATE_REQUEST
  EVALUATION_COMPLETED
  STAT_UPDATE_APPROVED
  APPLICATION_SUBMITTED
  APPLICATION_APPROVED
  APPLICATION_REJECTED
  APPLICATION_UNDER_REVIEW
  SYSTEM_ANNOUNCEMENT
  ACCOUNT_UPDATE
  SECURITY_ALERT
  NEW_FOLLOWER
  NEW_MESSAGE
  ROLE_UPDATED
  STAT_UPDATE_DENIED
  JOIN_REQUEST
  TEAM_INVITE
  TEAM_JOIN_REQUEST
  TEAM_MATCH_CHALLENGE
  TEAM_MATCH_ACCEPTED
  TEAM_MATCH_SCHEDULED
  TEAM_MATCH_RESULT
  TEAM_EXPIRING
  MEMBER_JOINED
  MEMBER_LEFT
  ROLE_CHANGED
  MESSAGE
  MENTION
  STAT_UPDATE_PERMISSION
  FOLLOW
}

// ============================================
// FRIEND SYSTEM
// ============================================
model Follow {
  id          String   @id @default(cuid())
  follower    Athlete  @relation("AthleteFollowers", fields: [followerId], references: [id], onDelete: Cascade)
  followerId  String
  following   Athlete  @relation("AthleteFollowing", fields: [followingId], references: [id], onDelete: Cascade)
  followingId String
  createdAt   DateTime @default(now())

  @@unique([followerId, followingId])
  @@index([followingId, followerId])
}

model AthleteCounters {
  athleteId      String   @id
  athlete        Athlete  @relation(fields: [athleteId], references: [id], onDelete: Cascade)
  followersCount Int      @default(0)
  followingCount Int      @default(0)
  postsCount     Int      @default(0)
  updatedAt      DateTime @updatedAt
}

// ============================================
// MESSAGING SYSTEM
// ============================================
model Conversation {
  id           String    @id @default(cuid())
  participants Athlete[] @relation("ConversationParticipants")
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  messages     Message[]

  @@index([createdAt])
}

model Message {
  id             String       @id @default(cuid())
  conversationId String
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  senderId       String
  sender         Athlete      @relation("MessagesSent", fields: [senderId], references: [id])
  content        String
  createdAt      DateTime     @default(now())
  imageUrl       String?

  @@index([conversationId])
  @@index([senderId])
}

model match {
  id         String  @id @default(cuid())
  matchTitle String?
  wins       Int?
  losses     Int?
}

// ============================================
// TEAM CORE
// ============================================

enum TeamStatus {
  PENDING_GUIDE_APPROVAL // waiting for guide to approve application
  PENDING_MEMBERS // guide approved, < 2 accepted members
  ACTIVE // >= 2 members
  REVOKED // manually or automatically revoked
  EXPIRED // for future use / archival
}

enum TeamMemberRole {
  OWNER
  CAPTAIN
  PLAYER
  MANAGER
}

enum TeamApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

model Team {
  id      String  @id @default(cuid())
  name    String
  bio     String?
  logoUrl String?

  // Classification / search
  sport Sport
  class Class?
  rank  Rank?

  // Location (for search and “nearby teams”)
  country   String?
  state     String?
  city      String?
  latitude  Float?
  longitude Float?

  // Owner (athlete who created the team)
  ownerId String
  owner   Athlete @relation("TeamsOwned", fields: [ownerId], references: [id])

  // Guide overseeing the team
  overseerGuideId String?
  overseerGuide   Guide?  @relation("GuideOverseerTeam", fields: [overseerGuideId], references: [id])

  status TeamStatus @default(PENDING_GUIDE_APPROVAL)

  // Relations
  teamApplicationId String?           @unique
  teamApplication   TeamApplication?  @relation(fields: [teamApplicationId], references: [id])
  members           TeamMembership[]
  invitations       TeamInvitation[]
  joinRequests      TeamJoinRequest[]
  messages          TeamMessage[]
  posts             TeamPost[]
  counters          TeamCounters?

  homeMatches           TeamMatch[]            @relation("HomeTeamMatches")
  awayMatches           TeamMatch[]            @relation("AwayTeamMatches")
  matchesWon            TeamMatch[]            @relation("WinnerTeam")
  matchesLost           TeamMatch[]            @relation("LoserTeam")
  teamMatchParticipants TeamMatchParticipant[] @relation("MatchParticipantTeam")

  // Optional: link back to the application that created this team

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // One athlete can own at most one team at a time
  @@unique([ownerId])
  // Search indexes
  @@index([name])
  @@index([sport, class, rank])
  @@index([country, state, city])
  @@index([status])
}

model TeamCounters {
  teamId        String   @id
  team          Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  membersCount  Int      @default(0)
  postsCount    Int      @default(0)
  matchesPlayed Int      @default(0)
  updatedAt     DateTime @updatedAt
}

// ============================================
// TEAM MEMBERSHIP & INVITES
// ============================================

enum TeamInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  EXPIRED
}

enum TeamJoinRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

model TeamMembership {
  id     String @id @default(cuid())
  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  athleteId String
  athlete   Athlete @relation(fields: [athleteId], references: [id], onDelete: Cascade)

  role      TeamMemberRole @default(PLAYER)
  // Optionally duplicate captain flag for quick checks
  isCaptain Boolean        @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Each athlete can only be in one team at a time (owner is also a member)
  @@unique([athleteId])
  @@index([teamId])
}

model TeamInvitation {
  id String @id @default(cuid())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  invitedAthleteId String
  invitedAthlete   Athlete @relation("Invitation_InvitedAthlete", fields: [invitedAthleteId], references: [id], onDelete: Cascade)

  invitedById String
  invitedBy   Athlete @relation("Invitation_InvitedBy", fields: [invitedById], references: [id])

  status      TeamInvitationStatus @default(PENDING)
  message     String?
  createdAt   DateTime             @default(now())
  respondedAt DateTime?

  @@unique([teamId, invitedAthleteId])
  @@index([invitedAthleteId, status])
}

model TeamJoinRequest {
  id String @id @default(cuid())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  athleteId String
  athlete   Athlete @relation("JoinRequest_Applicant", fields: [athleteId], references: [id], onDelete: Cascade)

  status  TeamJoinRequestStatus @default(PENDING)
  message String?

  reviewedById String?
  reviewedBy   Athlete? @relation("JoinRequest_Reviewer", fields: [reviewedById], references: [id])

  createdAt  DateTime  @default(now())
  reviewedAt DateTime?

  @@unique([teamId, athleteId])
  @@index([athleteId, status])
}

model TeamMessage {
  id String @id @default(cuid())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  senderId String
  sender   Athlete @relation("TeamMessageSender", fields: [senderId], references: [id])

  content   String
  imageUrl  String?
  createdAt DateTime @default(now())

  @@index([teamId, createdAt])
}

model TeamPost {
  id String @id @default(cuid())

  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  authorId String
  author   Athlete @relation("TeamPostAuthor", fields: [authorId], references: [id])

  type        TeamPostType @default(UPDATE)
  title       String?
  content     String?
  mediaUrls   String[]
  isPublished Boolean      @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([teamId, createdAt])
}

// ============================================
// TEAM CHAT & POSTS
// ============================================

enum TeamPostType {
  MATCH // match video/highlight
  PHOTO
  VIDEO
  UPDATE // general text / announcement
  OTHER
}

// ============================================
// TEAM APPLICATION (GUIDE APPROVAL)
// ============================================

model TeamApplication {
  id String @id @default(cuid())

  // Athlete applying to create a team
  applicantId String
  applicant   Athlete @relation("TeamApplicationApplicant", fields: [applicantId], references: [id], onDelete: Cascade)

  // Guide who reviews and (if approved) oversees the team
  guideId String
  guide   Guide  @relation("GuideTeamApplication", fields: [guideId], references: [id], onDelete: Cascade)

  // Proposed team details (snapshot)
  name      String
  sport     Sport
  class     Class?
  rank      Rank?
  bio       String?
  logoUrl   String?
  country   String?
  state     String?
  city      String?
  latitude  Float?
  longitude Float?

  status     TeamApplicationStatus @default(PENDING)
  reviewNote String?
  reviewedAt DateTime?
  // NEW back relation (one application → zero or one team)
  team       Team?
  // After approval you can create a Team and link back via Team.teamApplicationId
  createdAt  DateTime              @default(now())
  updatedAt  DateTime              @updatedAt

  @@index([guideId, status])
  @@index([applicantId, status])
}

// ============================================
// TEAM MATCH CHALLENGES
// ============================================

enum TeamMatchStatus {
  PENDING_CHALLENGE // challenge created, waiting for other team
  SCHEDULING // both accepted challenge, negotiating time/location
  SCHEDULED // final time/location locked in
  COMPLETED
  REJECTED // explicitly rejected before scheduling completes
  CANCELLED // cancelled after it was accepted/scheduled
}

model TeamMatch {
  id String @id @default(cuid())

  // Teams
  challengerTeamId String
  challengerTeam   Team   @relation("HomeTeamMatches", fields: [challengerTeamId], references: [id], onDelete: Cascade)

  challengedTeamId String
  challengedTeam   Team   @relation("AwayTeamMatches", fields: [challengedTeamId], references: [id], onDelete: Cascade)

  createdById        String
  createdBy          Athlete         @relation("TeamMatchCreator", fields: [createdById], references: [id])
  status             TeamMatchStatus @default(PENDING_CHALLENGE)
  // Initial challenge is implicitly accepted by challenger; challenged team must accept
  challengerAccepted Boolean         @default(true)
  challengedAccepted Boolean         @default(false)

  // PROPOSED schedule (editable while status = SCHEDULING)
  proposedStart     DateTime?
  proposedEnd       DateTime?
  proposedLocation  String?
  proposedLatitude  Float?
  proposedLongitude Float?

  // Each side's confirmation of the current proposal
  challengerConfirmed Boolean @default(false)
  challengedConfirmed Boolean @default(false)

  // FINAL, locked-in schedule
  scheduledStart     DateTime?
  scheduledEnd       DateTime?
  matchLengthMinutes Int?

  locationName String?
  latitude     Float?
  longitude    Float?

  // Guide overseeing the match (assigned by your “closest guide” logic)
  overseerGuideId String?
  overseerGuide   Guide?  @relation("GuideMatchOverseer", fields: [overseerGuideId], references: [id])
  // Outcome
  winnerTeamId    String?
  winnerTeam      Team?   @relation("WinnerTeam", fields: [winnerTeamId], references: [id])

  loserTeamId  String?
  loserTeam    Team?   @relation("LoserTeam", fields: [loserTeamId], references: [id])
  recordingUrl String? // VOD / full recording
  stats        Json? // key match stats, scoreboard, etc.

  participants TeamMatchParticipant[]

  // Optional metadata for cancellations/rescheduling (you can add later if needed)
  // cancelledByTeamId   String?
  // cancellationReason  String?
  // rescheduleOfMatchId String?
  // rescheduledToMatchId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([challengerTeamId, challengedTeamId])
  @@index([status, scheduledStart])
}

model TeamMatchParticipant {
  id String @id @default(cuid())

  matchId String
  match   TeamMatch @relation(fields: [matchId], references: [id], onDelete: Cascade)

  athleteId String
  athlete   Athlete @relation("MatchParticipantAthlete", fields: [athleteId], references: [id])

  teamId String
  team   Team   @relation("MatchParticipantTeam", fields: [teamId], references: [id])

  isStarter Boolean  @default(true)
  createdAt DateTime @default(now())

  @@unique([matchId, athleteId])
  @@index([teamId])
}

// ============================================
// ENUMS
// ============================================

// Access permission status
enum AccessStatus {
  REQUESTED
  GRANTED
  EXPIRED
  REVOKED
}

// Stats update approval status
enum StatsUpdateStatus {
  PENDING_REVIEW
  ACCEPTED
  REJECTED
}

enum FriendRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum Role {
  ATHLETE
  guide // Guide/Moderator
  ADMIN
}

enum ApplicationStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
  WITHDRAWN
}

enum Rank {
  KING
  PAWN
  ROOK
  KNIGHT
  BISHOP
  QUEEN
}

enum Class {
  A
  B
  C
  D
  E
}

enum Gender {
  MALE
  FEMALE
  OTHER
  PREFER_NOT_TO_SAY
}

enum Sport {
  FOOTBALL
  BASKETBALL
  CRICKET
  TENNIS
  RUNNING
  SWIMMING
  BADMINTON
  VOLLEYBALL
  HOCKEY
  ATHLETICS
  WRESTLING
  BOXING
  MARTIAL_ARTS
  CYCLING
  GOLF
  OTHER
}

// Request status tracking
enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}
